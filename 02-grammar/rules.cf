// ------------------------------------------------------------------
// > File:          rules.cf                                        
// ------------------------------------------------------------------
// > Author(s):     GOLLENSTEDE, Niklas                             
//                  HAUSWALD, Tom                                   
// ------------------------------------------------------------------
// > Description:                                                   
//      Contains the grammar definition used for the compiler       
//      construction course at TUHH during summer semester 2016.    
//      Implements language features per specification found at     
//      http://www1.digitalgrammars.com/ipl-book/assignments/       
//      assignment1/assignment1.html                                
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Lines starting with or enclosed by the following
// tokens will be completely ignored by the parser.
// ------------------------------------------------------------------
comment "//";
comment "/*" "*/";
comment "#";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// A program is a definition list of arbitrary length.
// ------------------------------------------------------------------
StdProgram.Program ::= [Definition];
terminator Definition "";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Definitions can be:
// 		- using statements
//		- typedefs
//		- variable declarations 
//		- (inline) function declarations & definitions
// ------------------------------------------------------------------
separator FunctionArgumentDeclaration ",";
UsingTypeDefinition.Definition                 ::= "using" BaseDatatype ";";
UsingNamespaceDefinition.Definition            ::= "using" "namespace" NamespaceName ";";
TypedefDefinition.Definition                   ::= Typedef ";";
VariableDeclarationDefinition.Definition       ::= VariableDeclaration ";";
FunctionDeclarationDefinition.Definition       ::= FunctionDeclaration ";";
FunctionDefinition.Definition                  ::= FunctionDeclaration Block;
InlineFunctionDeclarationDefinition.Definition ::= "inline" FunctionDeclaration ";";
InlineFunctionDefinition.Definition            ::= "inline" FunctionDeclaration Block;
StdFunctionDeclaration.FunctionDeclaration     ::= Datatype UUID "(" [FunctionArgumentDeclaration] ")";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Function arguments.
// ------------------------------------------------------------------
StdFunctionArgumentDeclaration.FunctionArgumentDeclaration       ::= Datatype Identifier;
AnonymousFunctionArgumentDeclaration.FunctionArgumentDeclaration ::= Datatype;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Typedefs can be statements as well as definitions.
// ------------------------------------------------------------------
StdTypedef.Typedef ::= "typedef" Datatype Identifier;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Variable declarations may optionally initialize the variable.
// ------------------------------------------------------------------
terminator VariableDeclarationList ";";
terminator VariableDeclaration ",";
StdVariableDeclarationList.VariableDeclarationList   ::= Datatype [VariableDeclaration] VariableDeclaration;
UninitializedVariableDeclaration.VariableDeclaration ::= Identifier;
InitializedVariableDeclaration.VariableDeclaration   ::= Identifier "=" RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Support data structures denoted by the struct keyword.
// ------------------------------------------------------------------
StdStruct.Struct ::= "struct" Identifier "{" [VariableDeclarationList] "}";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Statements can be collected inside blocks for scoping.
// ------------------------------------------------------------------
StdBlock.Block ::= "{" [Statement] "}";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Statement types.
// ------------------------------------------------------------------
terminator Statement "";
EmptyStatement.Statement                   ::= ";";
RValueStatement.Statement                  ::= RValue ";";
BlockStatement.Statement                   ::= Block;
VariableDeclarationListStatement.Statement ::= VariableDeclarationList ";";
ReturnStatement.Statement                  ::= "return" RValue ";";
ThrowStatement.Statement                   ::= "throw" RValue ";";
TypedefStatement.Statement                 ::= Typedef ";";
IfStatement.Statement                      ::= "if" "(" RValue ")" Statement;
IfElseStatement.Statement                  ::= "if" "(" RValue ")" Statement "else" Statement;
WhileLoopStatement.Statement               ::= "while" "(" RValue ")" Statement;
DoWhileLoopStatement.Statement             ::= "do" Statement "while" "(" RValue ")";
ForLoopStatement.Statement                 ::= "for" "(" VariableDeclarationList ";" RValue ";" RValue ")" Statement;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// LValues can be variables or dereferences.
// ------------------------------------------------------------------
VariableLValue.LValue  ::= UUID;
DerefenceLValue.LValue ::= Dereference;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Dereferences of struct instances (by pointer / value semantics)
// and array members.
// ------------------------------------------------------------------
StructDereference.Dereference  ::= RValue "." Identifier;
PointerDereference.Dereference ::= RValue "->" Identifier;
ArrayDereference.Dereference   ::= RValue "[" RValue "]";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Basic RValue types.
// ------------------------------------------------------------------
separator FunctionArgument ",";
ImplicitRValue.RValue                ::= LValue;
ConstantRValue.RValue                ::= Constant;
StructRValue.RValue                  ::= Struct;
ParenthesesRValue.RValue             ::= "(" RValue ")";
FunctionCallRValue.RValue            ::= RValue "(" [FunctionArgument] ")";
StdFunctionArgument.FunctionArgument ::= RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// RValues can be the result of operations.
// ------------------------------------------------------------------
AssignmentOperationRValue.RValue ::= AssignmentOperation;
UnaryOperationRValue.RValue      ::= UnaryOperation;
BinaryOperationRValue.RValue     ::= BinaryOperation;
TernaryOperationRValue.RValue    ::= TernaryOperation;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Assignment operations.
// ------------------------------------------------------------------
StdAssignmentOperation.AssignmentOperation     ::= LValue "=" RValue;
AddAssignmentOperation.AssignmentOperation     ::= LValue "+=" RValue;
SubAssignmentOperation.AssignmentOperation     ::= LValue "-=" RValue;
MulAssignmentOperation.AssignmentOperation     ::= LValue "*=" RValue;
DivAssignmentOperation.AssignmentOperation     ::= LValue "/=" RValue;
ModAssignmentOperation.AssignmentOperation     ::= LValue "%=" RValue;
AndAssignmentOperation.AssignmentOperation     ::= LValue "&=" RValue;
ArithOrAssignmentOperation.AssignmentOperation ::= LValue "|=" RValue;
// ------------------------------------------------------------------




// ------------------------------------------------------------------
// Unary operations.
// ------------------------------------------------------------------
ReferenceUnaryOperation.UnaryOperation     ::= "&" RValue;
DereferenceUnaryOperation.UnaryOperation   ::= "*" RValue;
NotUnaryOperation.UnaryOperation           ::= "!" RValue;
InvertUnaryOperation.UnaryOperation        ::= "~" RValue;
PreincrementUnaryOperation.UnaryOperation  ::= "++" RValue;
PostincrementUnaryOperation.UnaryOperation ::= RValue "++";
PredecrementUnaryOperation.UnaryOperation  ::= "--" RValue;
PostdecrementUnaryOperation.UnaryOperation ::= RValue "--";
NegateUnaryOperation.UnaryOperation        ::= "-" RValue;
// PositiveUnaryOperation.UnaryOperation   ::= "+" RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Binary operations.
// ------------------------------------------------------------------
CommaBinaryOperation.BinaryOperation            ::= RValue "," RValue;
AddBinaryOperation.BinaryOperation              ::= RValue "+" RValue;
SubBinaryOperation.BinaryOperation              ::= RValue "-" RValue;
MulBinaryOperation.BinaryOperation              ::= RValue "*" RValue;
DivBinaryOperation.BinaryOperation              ::= RValue "/" RValue;
ModBinaryOperation.BinaryOperation              ::= RValue "%" RValue;
LShiftBinaryOperation.BinaryOperation           ::= RValue "<<" RValue;
RShiftArithmeticBinaryOperation.BinaryOperation ::= RValue ">>" RValue;
RShiftLogicalBinaryOperation.BinaryOperation    ::= RValue ">>>" RValue;
ArithAndBinaryOperation.BinaryOperation         ::= RValue "&" RValue;
ArithOrBinaryOperation.BinaryOperation          ::= RValue "|" RValue;
BoolAndBinaryOperation.BinaryOperation          ::= RValue "&&" RValue;
BoolOrBinaryOperation.BinaryOperation           ::= RValue "||" RValue;
EqBinaryOperation.BinaryOperation               ::= RValue "==" RValue;
UneqBinaryOperation.BinaryOperation             ::= RValue "!=" RValue;
GreaterThanBinaryOperation.BinaryOperation      ::= RValue ">" RValue;
GreaterEqualThanBinaryOperation.BinaryOperation ::= RValue ">=" RValue;
LessThanBinaryOperation.BinaryOperation         ::= RValue "<" RValue;
LessEqualThanBinaryOperation.BinaryOperation    ::= RValue "<=" RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Ternary operations.
// ------------------------------------------------------------------
StdTernaryOperation.TernaryOperation ::= RValue "?" RValue ":" RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// UUIDs denote valid identifiers for variable, type 
// and function names. They may be nested arbitrarily deeply inside
// scopes.
// ------------------------------------------------------------------
terminator ScopeSegment "::";
StdUUID.UUID ::= [ScopeSegment] Identifier;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Valid datatypes.
// ------------------------------------------------------------------
StdDatatype.Datatype       ::= BaseDatatype;
ReferenceDatatype.Datatype ::= BaseDatatype "&";
PointerDatatype.Datatype   ::= Datatype "*";
ConstDatatype.Datatype     ::= "const" Datatype;
// ------------------------------------------------------------------
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Templates.
// ------------------------------------------------------------------
terminator TemplateArgument ",";
StdScopeSegment.ScopeSegment              ::= Identifier;
TemplateScopeSegment.ScopeSegment         ::= Identifier "<" [TemplateArgument] TemplateArgument ">";
ConstantTemplateArgument.TemplateArgument ::= Constant;
TypenameTemplateArgument.TemplateArgument ::= Datatype;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Base datatypes.
// ------------------------------------------------------------------
PrimitiveBaseDatatype.BaseDatatype ::= BuiltinPrimitive;
ComplexBaseDatatype.BaseDatatype   ::= [ScopeSegment] ScopeSegment;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Namespace names.
// ------------------------------------------------------------------
StdNamespaceName.NamespaceName    ::= Identifier;
ScopedNamespaceName.NamespaceName ::= NamespaceName "::" Identifier;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Constant values.
// ------------------------------------------------------------------
separator String "";
IntConstant.Constant    ::= Integer;
StringConstant.Constant ::= [String] String;
DoubleConstant.Constant ::= Double;
CharConstant.Constant   ::= Char;
TrueConstant.Constant   ::= "true";
FalseConstant.Constant  ::= "false";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Builtin primitive types.
// ------------------------------------------------------------------
VoidPrimitiveDatatype.BuiltinPrimitive        ::= "void";
BoolPrimitiveDatatype.BuiltinPrimitive        ::= "bool";
CharPrimitiveDatatype.BuiltinPrimitive        ::= "char";
ShortIntPrimitiveDatatype.BuiltinPrimitive    ::= "short" "int";
IntPrimitiveDatatype.BuiltinPrimitive         ::= "int";
LongIntPrimitiveDatatype.BuiltinPrimitive     ::= "long" "int";
LongLongIntPrimitiveDatatype.BuiltinPrimitive ::= "long" "long" "int";
FloatPrimitiveDatatype.BuiltinPrimitive       ::= "float";
DoublePrimitiveDatatype.BuiltinPrimitive      ::= "double";
LongDoublePrimitiveDatatype.BuiltinPrimitive  ::= "long" "double";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// General identifier structure.
// ------------------------------------------------------------------
token Identifier (letter(letter|digit|'_')*)
// ------------------------------------------------------------------
