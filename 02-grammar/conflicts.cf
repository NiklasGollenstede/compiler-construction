// ------------------------------------------------------------------
// > File:          rules.cf
// ------------------------------------------------------------------
// > Author(s):     GOLLENSTEDE, Niklas
//                  HAUSWALD, Tom
// ------------------------------------------------------------------
// > Description:
//      Contains the grammar definition used for the compiler
//      construction course at TUHH during summer semester 2016.
//      Implements language features per specification found at
//      http://www1.digitalgrammars.com/ipl-book/assignments/
//      assignment1/assignment1.html
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Lines starting with or enclosed by the following
// tokens will be completely ignored by the parser.
// ------------------------------------------------------------------
comment "//";
comment "/*" "*/";
comment "#";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// A program is a definition list of arbitrary length.
// ------------------------------------------------------------------
StdProgram.Program ::= [Definition];
terminator Definition "";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Definitions can be:
// 		- using statements
//		- typedefs
//		- variable declarations
//		- (inline) function declarations & definitions
// ------------------------------------------------------------------
UsingTypeDefinition.Definition                 ::= "using" BaseDatatype ";";
UsingNamespaceDefinition.Definition            ::= "using" "namespace" NamespaceName ";";
TypedefDefinition.Definition                   ::= Typedef ";";
StructDefinition.Definition                    ::= Struct ";";
VariableDeclarationListDefinition.Definition   ::= VariableDeclarationList ";";
FunctionDeclarationDefinition.Definition       ::= FunctionDeclaration ";";
FunctionDefinition.Definition                  ::= FunctionDeclaration Block;
InlineFunctionDeclarationDefinition.Definition ::= "inline" FunctionDeclaration ";";
InlineFunctionDefinition.Definition            ::= "inline" FunctionDeclaration Block;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Function signature.
// ------------------------------------------------------------------
separator ArgumentDeclaration ",";
StdFunctionDeclaration.FunctionDeclaration ::= Datatype Identifier "(" [ArgumentDeclaration] ")";

// Argument declaration types. (simple, unnamed or w/ default value.)
StdArgumentDeclaration.ArgumentDeclaration         ::= Datatype ArgumentName;
StdArgumentName.ArgumentName                       ::= Identifier ArgumentInitialization;
EmptyArgumentName.ArgumentName                     ::= ;
StdArgumentInitialization.ArgumentInitialization   ::= "=" RValue;
EmptyArgumentInitialization.ArgumentInitialization ::= ;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Typedefs can be statements as well as definitions.
// ------------------------------------------------------------------
StdTypedef.Typedef ::= "typedef" Datatype Identifier;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Variable declarations may optionally initialize the variable.
// ------------------------------------------------------------------
separator nonempty VariableDeclaration ",";
StdVariableDeclarationList.VariableDeclarationList   ::= Datatype [VariableDeclaration];
UninitializedVariableDeclaration.VariableDeclaration ::= Identifier;
InitializedVariableDeclaration.VariableDeclaration   ::= Identifier "=" RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Support data structures denoted by the struct keyword.
// ------------------------------------------------------------------
terminator VariableDeclarationList ";";
StdStruct.Struct ::= "struct" Identifier "{" [VariableDeclarationList] "}";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Statements can be collected inside blocks for scoping.
// ------------------------------------------------------------------
StdBlock.Block ::= "{" [Statement] "}";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Statement types.
// ------------------------------------------------------------------
terminator Statement "";
EmptyStatement.Statement                   ::= ";";
RValueStatement.Statement                  ::= RValue ";";
BlockStatement.Statement                   ::= Block;
StructStatement.Statement                  ::= Struct ";";
VariableDeclarationListStatement.Statement ::= VariableDeclarationList ";";
ReturnStatement.Statement                  ::= "return" RValue ";";
ThrowStatement.Statement                   ::= "throw" RValue ";";
TypedefStatement.Statement                 ::= Typedef ";";
IfStatement.Statement                      ::= "if" "(" RValue ")" Statement;
IfElseStatement.Statement                  ::= "if" "(" RValue ")" Statement "else" Statement;
WhileLoopStatement.Statement               ::= "while" "(" RValue ")" Statement;
DoWhileLoopStatement.Statement             ::= "do" Statement "while" "(" RValue ")";
ForLoopStatement.Statement                 ::= "for" "(" VariableDeclarationList ";" RValue ";" RValue ")" Statement;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// LValues can be variables or dereferences.
// ------------------------------------------------------------------
VariableLValue.LValue  ::= QualifiedName;
DerefenceLValue.LValue ::= Dereference;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Dereferences of struct instances (by pointer / value semantics)
// and array members.
// ------------------------------------------------------------------
StructDereference.Dereference  ::= RValue "." Identifier;
PointerDereference.Dereference ::= RValue "->" Identifier;
ArrayDereference.Dereference   ::= RValue "[" RValue "]";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Basic RValue types.
// ------------------------------------------------------------------
ImplicitRValue         .RValue ::= LValue;
ConstantRValue         .RValue ::= Constant;
ParenthesesRValue      .RValue ::= "(" RValue ")";
OperatorRValue         .RValue ::= Operation;
separator               FunctionArgument ",";
StdFunctionArgument    .FunctionArgument ::= RValue;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// RValues can be the result of operations.
// ------------------------------------------------------------------
PostIncUnaryOperation      .Operation2 ::= RValue "++";
PostDecUnaryOperation      .Operation2 ::= RValue "--";
FuncCallBinaryOperation    .Operation2 ::= RValue "(" [FunctionArgument] ")";
// SubscriptBinaryOperation   .Operation2 ::= RValue "[" RValue "]";
// DotMemBinaryOperation      .Operation2 ::= RValue "." Identifier;
// ArrowMemBinaryOperation    .Operation2 ::= RValue "->" Identifier;

PreIncUnaryOperation       .Operation3 ::= "++" RValue;
PreDecUnaryOperation       .Operation3 ::= "--" RValue;
PositiveUnaryOperation     .Operation3 ::= "+" RValue;
NegativeUnaryOperation     .Operation3 ::= "-" RValue;
NotUnaryOperation          .Operation3 ::= "!" RValue;
InvertUnaryOperation       .Operation3 ::= "~" RValue;
DeRefUnaryOperation        .Operation3 ::= "*" RValue;
RefUnaryOperation          .Operation3 ::= "&" RValue;

MulBinaryOperation         .Operation5 ::= RValue "*" RValue;
DivBinaryOperation         .Operation5 ::= RValue "/" RValue;
ModBinaryOperation         .Operation5 ::= RValue "%" RValue;

AddBinaryOperation         .Operation6 ::= RValue "+" RValue;
SubBinaryOperation         .Operation6 ::= RValue "-" RValue;

LShiftBinaryOperation      .Operation7 ::= RValue "<<" RValue;
RShiftBinaryOperation      .Operation7 ::= RValue ">>" RValue;

GrBinaryOperation          .Operation8 ::= RValue ">" RValue;
GrEqBinaryOperation        .Operation8 ::= RValue ">=" RValue;
LsBinaryOperation          .Operation8 ::= RValue "<" RValue;
LsEqBinaryOperation        .Operation8 ::= RValue "<=" RValue;

EqBinaryOperation          .Operation9 ::= RValue "==" RValue;
NotEqBinaryOperation       .Operation9 ::= RValue "!=" RValue;

AndBitBinaryOperation      .Operation10 ::= RValue "&" RValue;
XorBitBinaryOperation      .Operation11 ::= RValue "^" RValue;
OrBitBinaryOperation       .Operation12 ::= RValue "|" RValue;

AndBinaryOperation         .Operation13 ::= RValue "&&" RValue;
OrBinaryOperation          .Operation14 ::= RValue "||" RValue;

StdTernaryOperation        .Operation15 ::= RValue "?" RValue ":" RValue;
StdAssignmentOperation     .Operation15 ::= LValue "=" RValue;
AddAssignmentOperation     .Operation15 ::= LValue "+=" RValue;
SubAssignmentOperation     .Operation15 ::= LValue "-=" RValue;
MulAssignmentOperation     .Operation15 ::= LValue "*=" RValue;
DivAssignmentOperation     .Operation15 ::= LValue "/=" RValue;
ModAssignmentOperation     .Operation15 ::= LValue "%=" RValue;
LShiftAssignmentOperation  .Operation15 ::= LValue "<<=" RValue;
RShiftAssignmentOperation  .Operation15 ::= LValue ">>=" RValue;
AndBitAssignmentOperation  .Operation15 ::= LValue "&=" RValue;
XorBitAssignmentOperation  .Operation15 ::= LValue "^=" RValue;
OrBitAssignmentOperation   .Operation15 ::= LValue "|=" RValue;

// CommaBinaryOperation       .Operation16 ::= RValue "," RValue;
coercions Operation 15;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Valid datatypes.
// ------------------------------------------------------------------
StdDatatype.Datatype       ::= BaseDatatype;
ConstDatatype.Datatype     ::= "const" BaseDatatype;

// References.
ReferenceDatatype.Datatype ::= BaseDatatype "&";
ConstReferenceDatatype.Datatype ::= "const" BaseDatatype "&";
ReferenceConstDatatype.Datatype ::= BaseDatatype "const" "&";

// Pointers.
PointerDatatype.Datatype   ::= Datatype "*";
ConstPointerDatatype.Datatype ::= "const" BaseDatatype "*";
PointerConstDatatype.Datatype ::= BaseDatatype "const" "*";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Base datatypes.
// ------------------------------------------------------------------
PrimitiveBaseDatatype.BaseDatatype ::= BuiltinPrimitive;
ComplexBaseDatatype.BaseDatatype   ::= QualifiedName;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Item names denote valid identifiers to access variables
// and functions. (They may be nested arbitrarily deeply inside
// scopes.)
// ------------------------------------------------------------------
separator nonempty QualifiedNameSegment "::";
StdQualifiedName.QualifiedName ::= [QualifiedNameSegment];
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Templates.
// ------------------------------------------------------------------
separator nonempty TemplateArgument ",";
StdQualifiedNameSegment.QualifiedNameSegment      ::= Identifier;
TemplateQualifiedNameSegment.QualifiedNameSegment ::= Identifier "<" [TemplateArgument] ">";
ConstantTemplateArgument.TemplateArgument         ::= Constant;
TypenameTemplateArgument.TemplateArgument         ::= Datatype;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Namespace names.
// ------------------------------------------------------------------
StdNamespaceName.NamespaceName    ::= Identifier;
ScopedNamespaceName.NamespaceName ::= NamespaceName "::" Identifier;
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Constant values.
// ------------------------------------------------------------------
separator String "";
IntConstant.Constant    ::= Integer;
StringConstant.Constant ::= [String] String;
DoubleConstant.Constant ::= Double;
CharConstant.Constant   ::= Char;
TrueConstant.Constant   ::= "true";
FalseConstant.Constant  ::= "false";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// Builtin primitive types.
// ------------------------------------------------------------------
VoidPrimitiveDatatype.BuiltinPrimitive        ::= "void";
BoolPrimitiveDatatype.BuiltinPrimitive        ::= "bool";
CharPrimitiveDatatype.BuiltinPrimitive        ::= "char";
ShortIntPrimitiveDatatype.BuiltinPrimitive    ::= "short" "int";
IntPrimitiveDatatype.BuiltinPrimitive         ::= "int";
LongIntPrimitiveDatatype.BuiltinPrimitive     ::= "long" "int";
LongLongIntPrimitiveDatatype.BuiltinPrimitive ::= "long" "long" "int";
FloatPrimitiveDatatype.BuiltinPrimitive       ::= "float";
DoublePrimitiveDatatype.BuiltinPrimitive      ::= "double";
LongDoublePrimitiveDatatype.BuiltinPrimitive  ::= "long" "double";
// ------------------------------------------------------------------



// ------------------------------------------------------------------
// General identifier structure.
// ------------------------------------------------------------------
token Identifier (letter(letter|digit|'_')*);
// ------------------------------------------------------------------
